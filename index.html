<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>COC7 æˆ˜æ–—æ§åˆ¶å°å¢å¼ºç‰ˆ v2.3 (Mobile Fix)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { box-sizing: border-box; }
        
        /* æ ¸å¿ƒä¿®å¤ 1: ä½¿ç”¨ dvh è§£å†³ç§»åŠ¨ç«¯åœ°å€æ å’Œé”®ç›˜å¯¼è‡´çš„é«˜åº¦é—®é¢˜ */
        html, body { 
            height: 100vh; /* å…¼å®¹æ—§æµè§ˆå™¨ */
            height: 100dvh; /* æ ¸å¿ƒä¿®å¤ï¼šåŠ¨æ€è§†å£é«˜åº¦ */
            width: 100vw;
            margin: 0; 
            padding: 0;
            overflow: hidden; 
            position: fixed; /* é˜²æ­¢æ©¡çš®ç­‹æ•ˆæœ */
            overscroll-behavior: none;
        }

        #root {
            height: 100%;
            width: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* å¸ƒå±€å®¹å™¨ */
        .main-layout {
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* å¤´éƒ¨å›ºå®š */
        header {
            flex: 0 0 56px;
        }

        /* ä¸»å†…å®¹åŒºåŸŸè‡ªé€‚åº” */
        main {
            flex: 1;
            overflow: hidden;
            position: relative;
            height: calc(100% - 56px); /* Fallback */
            display: flex;
            flex-direction: column;
        }

        .combat-grid {
            display: grid;
            grid-template-columns: 280px 1fr 300px;
            height: 100%;
            overflow: hidden;
        }

        /* é¢æ¿é€šç”¨æ ·å¼ */
        .panel-scroll {
            height: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }

        /* å·¦ä¾§é¢æ¿ */
        .panel-left {
            background-color: #f9fafb;
            border-right: 1px solid #e5e7eb;
        }

        /* å³ä¾§æ—¥å¿—é¢æ¿ */
        .panel-right {
            background-color: white;
            border-left: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }
        
        .log-scroll-area {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }

        /* ä¸­é—´é¢æ¿ */
        .panel-center {
            position: relative;
            background-color: #f3f4f6;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .target-bar {
            flex-shrink: 0;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            border-bottom: 1px solid #e5e7eb;
            z-index: 20;
        }

        .action-area {
            flex: 1;
            position: relative;
            overflow-y: auto; /* ç¡®ä¿ä¸­é—´åŒºåŸŸæœ¬èº«å¯æ»šåŠ¨ */
            -webkit-overflow-scrolling: touch;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .centered-card {
            width: 90%;
            max-width: 440px;
            max-height: 90%; /* é˜²æ­¢æº¢å‡º */
            overflow-y: auto; /* å†…å®¹è¿‡å¤šæ—¶å¡ç‰‡å†…éƒ¨æ»šåŠ¨ */
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e7eb;
            z-index: 10;
            margin: auto; /* Flexå±…ä¸­æ›¿ä»£ç»å¯¹å®šä½ */
        }

        /* KPæ§åˆ¶å°æ ·å¼ */
        .kp-panel {
            position: fixed;
            top: 56px;
            right: 0;
            bottom: 0;
            width: 350px;
            background: white;
            border-left: 2px solid #dc2626;
            z-index: 100;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            overflow-y: auto;
            box-shadow: -4px 0 20px rgba(0,0,0,0.15);
        }

        .kp-panel.open {
            transform: translateX(0);
        }

        /* æ»šåŠ¨æ¡ç¾åŒ– */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        .weapon-card {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            background: white;
            transition: all 0.2s;
        }
        .weapon-card.active { border-color: #3b82f6; box-shadow: 0 0 0 1px #3b82f6; }

        .skill-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 8px; border-radius: 6px; margin-bottom: 4px;
            background: #f8fafc; border: 1px solid #e2e8f0;
        }
        .skill-item.multi-target {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-color: #f59e0b;
        }

        /* =========================================
           æ ¸å¿ƒä¿®å¤ï¼šç§»åŠ¨ç«¯é€‚é… (Max-width 1024px)
           ========================================= */
        @media (max-width: 1024px) {
            /* é˜²æ­¢ iOS è¾“å…¥æ¡†èšç„¦ç¼©æ”¾ */
            input, select, textarea {
                font-size: 16px !important; 
            }

            .combat-grid {
                display: flex; /* æ”¹ä¸º flex æ–¹ä¾¿æ§åˆ¶æ˜¾éš */
                flex-direction: column;
                height: 100%;
                width: 100%;
            }

            /* é¢æ¿åˆ‡æ¢é€»è¾‘ */
            .panel-left, .panel-center, .panel-right {
                display: none; /* é»˜è®¤éšè— */
                width: 100%;
                height: 100%; /* å æ»¡å®¹å™¨ */
                border: none;
                position: static; /* ç§»é™¤ fixedï¼Œå›å½’æµå¼å¸ƒå±€ */
            }

            .panel-mobile-active {
                display: flex !important;
                flex-direction: column;
            }

            /* ä¿®å¤è®¾ç½®é¡µé¢çš„æ»šåŠ¨é—®é¢˜ - æ ¸å¿ƒä¿®å¤ç‚¹ */
            .setup-grid {
                display: flex !important; /* å¼ºåˆ¶ Flex */
                flex-direction: column;
                height: 100%;
                overflow: hidden;
            }

            .setup-sidebar {
                width: 100% !important;
                flex: 0 0 auto; /* å›ºå®šé«˜åº¦ï¼Œä¸ä¼¸ç¼© */
                max-height: 35vh; /* é™åˆ¶é«˜åº¦ï¼Œç•™ç©ºé—´ç»™å†…å®¹ */
                overflow-y: auto;
                border-right: none !important;
                border-bottom: 1px solid #e5e7eb;
                background: #f9fafb;
                z-index: 20;
            }

            .setup-content {
                flex: 1; /* å æ®å‰©ä½™é«˜åº¦ */
                overflow-y: auto !important; /* å¿…é¡»æ˜¾å¼å¼€å¯æ»šåŠ¨ */
                padding: 16px !important;
                padding-bottom: 80px !important; /* åº•éƒ¨ç•™ç™½ï¼Œé˜²æ­¢è¢«é”®ç›˜é¡¶èµ·æ—¶æ— æ³•æ»šåŠ¨åˆ°åº• */
            }

            /* ç«–å±æ¨¡å¼è°ƒæ•´ */
            @media (orientation: portrait) {
                .centered-card {
                    width: 95%;
                    margin: 10px auto;
                    max-height: none; /* å…è®¸æ’‘å¼€ */
                    flex: 1; /* åœ¨ Flex å®¹å™¨ä¸­è‡ªé€‚åº” */
                    display: flex;
                    flex-direction: column;
                }
                
                /* ç¡®ä¿å¡ç‰‡å†…éƒ¨å†…å®¹å¯æ»šåŠ¨ */
                .centered-card > div {
                    overflow-y: visible; 
                }
            }

            /* æ¨ªå±æ¨¡å¼ */
            @media (orientation: landscape) {
                .combat-grid {
                    display: grid;
                    grid-template-columns: 200px 1fr 240px;
                }
                .panel-left, .panel-center, .panel-right {
                    display: flex !important;
                    height: 100%;
                }
                .mobile-nav { display: none !important; }
                .setup-grid { flex-direction: row !important; }
                .setup-sidebar { 
                    width: 200px !important; 
                    height: 100% !important; 
                    max-height: none;
                    border-right: 1px solid #e5e7eb !important;
                }
            }
            
            .kp-panel { width: 100%; top: 0; }
            .kp-panel.open { padding-top: 56px; }
        }

        /* é”®ç›˜å¼¹å‡ºæ—¶çš„æç«¯æƒ…å†µé€‚é… */
        @media (max-height: 500px) and (orientation: portrait) {
            header { display: none; } /* é”®ç›˜å¼¹å‡ºæ—¶éšè—å¤´éƒ¨èŠ‚çœç©ºé—´ */
            .setup-sidebar { display: none; } /* å¡«å†™æ—¶éšè—ä¾§è¾¹æ  */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
/* é€»è¾‘éƒ¨åˆ†ä¿æŒä¸å˜ï¼Œä»…ä¿®å¤æ ·å¼é€‚é…é—®é¢˜
   ... (Logics kept exactly the same as original)
*/
const { useState, useEffect, useMemo, useRef } = React;

// ... (Copying all constants and helper functions from original file) ...
const BASE_CHARACTER = {
  str: 50, con: 50, siz: 60, dex: 50,
  fight: 50, firearms: 20, dodge: 25,
  armorValue: 0, hasGunReady: false,
  activeWeapon: { name: "æ‹³å¤´", damage: "1D3", type: "melee", impale: false },
  weapons: [], 
  customSkills: [], 
  status: { majorWound: false, dying: false, unconscious: false, prone: false, defenseUsedThisRound: false }
};

const MELEE_WEAPONS = [
  { name: "æ‹³å¤´", damage: "1D3", type: "melee", impale: false, range: 1 },
  { name: "å°åˆ€", damage: "1D4", type: "melee", impale: true, range: 1 },
  { name: "æ£’çƒæ£", damage: "1D8", type: "melee", impale: false, range: 2 },
  { name: "æ–§å¤´", damage: "1D8+1", type: "melee", impale: false, range: 2 },
  { name: "é•¿å‰‘", damage: "1D8+1", type: "melee", impale: true, range: 2 },
  { name: "åŒ•é¦–", damage: "1D4+2", type: "melee", impale: true, range: 1 },
  { name: "æˆ˜é”¤", damage: "1D8+2", type: "melee", impale: false, range: 2 },
  { name: "é•¿çŸ›", damage: "1D8+1", type: "melee", impale: true, range: 3 }
];

const RANGED_WEAPONS = [
  { name: "æ‰‹æª", damage: "1D10", type: "ranged", impale: false, range: 15, ammo: 7, malfunction: 100 },
  { name: "æ­¥æª", damage: "2D6+4", type: "ranged", impale: true, range: 110, ammo: 5, malfunction: 100 },
  { name: "éœ°å¼¹æª", damage: "4D6", type: "ranged", impale: false, range: 10, ammo: 2, malfunction: 100 },
  { name: "å†²é”‹æª", damage: "1D10", type: "ranged", impale: false, range: 20, ammo: 15, malfunction: 96, autoFire: true },
  { name: "å¼©", damage: "1D8+2", type: "ranged", impale: true, range: 50, ammo: 1, malfunction: 97 },
  { name: "å·¦è½®æ‰‹æª", damage: "1D10+2", type: "ranged", impale: true, range: 15, ammo: 6, malfunction: 100 },
  { name: "çŒæª", damage: "2D6+2", type: "ranged", impale: true, range: 80, ammo: 2, malfunction: 100 }
];

const WEAPON_PRESETS = [...MELEE_WEAPONS, ...RANGED_WEAPONS];

const SKILL_TEMPLATES = [
  { id: 'fire_burst', name: 'ç«åŠ›å‹åˆ¶', description: 'å¯¹å¤šä¸ªç›¸é‚»ç›®æ ‡è¿›è¡Œå°„å‡»', type: 'multi_attack', baseCost: 3, maxTargets: 3, difficultyModifier: 1, damageModifier: 0.8 },
  { id: 'aimed_shot', name: 'ç²¾å‡†å°„å‡»', description: 'èŠ±è´¹1è½®ç„å‡†ï¼Œä¸‹è½®è·å¾—å¥–åŠ±éª°', type: 'buff', duration: 1, effect: { bonusDice: 1 } },
  { id: 'berserker_rage', name: 'ç‹‚æš´', description: 'å¢åŠ è¿‘æˆ˜ä¼¤å®³ä½†é™ä½é˜²å¾¡', type: 'buff', duration: 3, effect: { damageBonus: 4, dodgePenalty: 2 } },
  { id: 'suppression', name: 'å‹åˆ¶å°„å‡»', description: 'é™ä½æ•Œäººä¸‹å›åˆå‘½ä¸­ç‡', type: 'debuff', duration: 1, effect: { penaltyDice: 2 } }
];

const rollDice = (expr) => {
  const match = expr.match(/(\d+)[dD](\d+)(?:\+(\d+))?(?:\-(\d+))?/);
  if (!match) return { total: parseInt(expr) || 0, rolls: [] };
  const [, numStr, sidesStr, plusStr, minusStr] = match;
  const num = parseInt(numStr), sides = parseInt(sidesStr);
  const plus = parseInt(plusStr) || 0, minus = parseInt(minusStr) || 0;
  const rolls = Array(num).fill().map(() => Math.floor(Math.random() * sides) + 1);
  return { total: rolls.reduce((s, r) => s + r, 0) + plus - minus, rolls };
};

const getMaxDamage = (expr) => {
  const match = expr.match(/(\d+)[dD](\d+)(?:\+(\d+))?(?:\-(\d+))?/);
  if (!match) return parseInt(expr) || 0;
  const [, numStr, sidesStr, plusStr, minusStr] = match;
  const num = parseInt(numStr), sides = parseInt(sidesStr);
  const plus = parseInt(plusStr) || 0, minus = parseInt(minusStr) || 0;
  return num * sides + plus - minus;
};

const calcDerived = (c) => {
  const hp = Math.floor((c.con + c.siz) / 10);
  const mov = c.str < c.siz && c.dex < c.siz ? 7 : c.str > c.siz && c.dex > c.siz ? 9 : 8;
  const sum = c.str + c.siz;
  let db = '0', build = 0;
  if (sum <= 64) { db = '-2'; build = -2; }
  else if (sum <= 84) { db = '-1'; build = -1; }
  else if (sum <= 124) { db = '0'; build = 0; }
  else if (sum <= 164) { db = '1D4'; build = 1; }
  else if (sum <= 204) { db = '1D6'; build = 2; }
  else { db = '2D6'; build = 3; }
  return { maxHp: hp, mov, db, build };
};

const calculateSuccessLevel = (roll, skill) => {
  if (roll === 1) return 4;
  if (roll <= Math.floor(skill / 5)) return 3;
  if (roll <= Math.floor(skill / 2)) return 2;
  if (roll <= skill) return 1;
  if (skill < 50 && roll >= 96) return -1;
  if (roll === 100) return -1;
  return 0;
};

const getSuccessLabel = (level) => ({ 4: 'å¤§æˆåŠŸ', 3: 'æéš¾æˆåŠŸ', 2: 'å›°éš¾æˆåŠŸ', 1: 'å¸¸è§„æˆåŠŸ', 0: 'å¤±è´¥', '-1': 'å¤§å¤±è´¥' }[level] || 'æœªçŸ¥');

const executeOpposedCheck = (atkSkill, defSkill, atkRoll, defRoll, defType) => {
  const atkLvl = calculateSuccessLevel(atkRoll, atkSkill);
  const defLvl = calculateSuccessLevel(defRoll, defSkill);
  if (atkLvl > defLvl) return { success: true, winner: 'attacker', atkLvl, defLvl };
  if (defLvl > atkLvl) return { success: false, winner: 'defender', atkLvl, defLvl };
  return { success: defType === 'counter', winner: defType === 'counter' ? 'attacker' : 'defender', atkLvl, defLvl, isTie: true };
};

const calculateDamage = (weapon, attacker, successLevel, isCounterAttack) => {
  if (isCounterAttack) successLevel = Math.min(successLevel, 2);
  const wDmg = rollDice(weapon.damage);
  const dbDmg = attacker.db !== '0' ? rollDice(attacker.db) : { total: 0, rolls: [] };
  let total = wDmg.total + dbDmg.total;
  let log = `${wDmg.total}(æ­¦å™¨)`;
  if (dbDmg.total !== 0) log += ` + ${dbDmg.total}(DB)`;
  
  if (successLevel >= 3) {
    const maxW = getMaxDamage(weapon.damage);
    const maxDB = attacker.db !== '0' ? getMaxDamage(attacker.db) : 0;
    if (weapon.impale) {
      const extra = rollDice(weapon.damage);
      total = maxW + maxDB + extra.total;
      log = `${maxW}(æœ€å¤§)+${maxDB}(DB)+${extra.total}(è´¯ç©¿)`;
    } else {
      total = maxW + maxDB;
      log = `${maxW}(æœ€å¤§)+${maxDB}(DB)`;
    }
  }
  return { total: Math.max(0, total), damageLog: log };
};

const calculateMultiTargetAttack = (skill, weapon, targets, customSkill) => {
  const results = [];
  let penaltyDice = 0;
  targets.forEach((target, index) => {
    const effectiveSkill = Math.max(5, skill - (penaltyDice * 10));
    const roll = Math.floor(Math.random() * 100) + 1;
    const successLevel = calculateSuccessLevel(roll, effectiveSkill);
    if (successLevel > 0) {
      const damage = calculateDamage(weapon, targets[0], successLevel);
      results.push({ target, roll, successLevel, damage: Math.floor(damage.total * (customSkill.damageModifier || 1)), hit: true });
    } else {
      results.push({ target, roll, successLevel, damage: 0, hit: false });
    }
    penaltyDice += customSkill.difficultyModifier || 1;
  });
  return results;
};

const generateId = () => Math.random().toString(36).substr(2, 9);

function App() {
  const [view, setView] = useState('setup');
  const [characters, setCharacters] = useState([]);
  const [logs, setLogs] = useState([]);
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [isManualDice, setIsManualDice] = useState(true);
  const [turn, setTurn] = useState({ round: 1, index: 0 });
  const [history, setHistory] = useState([]);
  const [kpPanelOpen, setKpPanelOpen] = useState(false);
  const logContainerRef = useRef(null);

  useEffect(() => {
    if (logContainerRef.current) {
      const { scrollHeight, clientHeight } = logContainerRef.current;
      if (scrollHeight > clientHeight) {
        logContainerRef.current.scrollTop = scrollHeight;
      }
    }
  }, [logs]);

  const saveToHistory = () => {
    setHistory(prev => [...prev.slice(-19), {
      characters: JSON.parse(JSON.stringify(characters)),
      turn: { ...turn },
      logs: [...logs]
    }]);
  };

  const undo = () => {
    if (history.length === 0) return;
    const last = history[history.length - 1];
    setCharacters(last.characters);
    setTurn(last.turn);
    setLogs(last.logs);
    setHistory(prev => prev.slice(0, -1));
  };

  const addLog = (text, type = 'info') => {
    setLogs(prev => [...prev, { id: Date.now(), text, type, time: new Date().toLocaleTimeString().slice(0, 8) }]);
  };

  const combatOrder = useMemo(() => [...characters].sort((a, b) => {
    const aDex = a.hasGunReady ? a.dex + 50 : a.dex;
    const bDex = b.hasGunReady ? b.dex + 50 : b.dex;
    return bDex !== aDex ? bDex - aDex : b.fight - a.fight;
  }), [characters]);

  const currentActor = useMemo(() => combatOrder[turn.index % combatOrder.length], [combatOrder, turn.index]);

  const updateChar = (id, updates) => {
    setCharacters(prev => prev.map(c => {
      if (c.id !== id) return c;
      const updated = { ...c, ...updates };
      const derived = calcDerived(updated);
      return { ...updated, ...derived, hp: Math.min(updated.hp, derived.maxHp) };
    }));
  };

  const startNewRound = () => {
    setCharacters(prev => prev.map(c => ({ ...c, status: { ...c.status, defenseUsedThisRound: false } })));
  };

  return (
    <div className="main-layout font-sans text-gray-900 bg-gray-100">
      <header className="h-14 border-b border-gray-200 flex items-center justify-between px-4 bg-white shrink-0 z-30 shadow-sm relative">
        <div className="flex items-center gap-2">
          <div className="w-6 h-6 bg-gray-900 flex items-center justify-center text-white font-bold text-xs rounded">C7</div>
          <h1 className="font-bold text-base hidden sm:block">COC7 æˆ˜æ–—æ§åˆ¶å° <span className="text-gray-400 font-normal text-xs">v2.3 å¢å¼ºç‰ˆ</span></h1>
          <h1 className="font-bold text-base sm:hidden">COC7</h1>
        </div>
        <div className="flex items-center gap-3">
          {view === 'setup' && (
            <button onClick={() => { if(characters.length<1) return alert("è‡³å°‘æ·»åŠ ä¸€ä¸ªè§’è‰²"); setView('combat'); addLog("ğŸ æˆ˜æ–—å¼€å§‹", "system"); }} className="bg-gray-900 text-white px-3 py-1.5 rounded text-xs font-bold hover:bg-gray-800 shadow-sm">âš”ï¸ å¯åŠ¨</button>
          )}
          {view === 'combat' && (
            <>
              <span className="font-mono text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded">R{turn.round}</span>
              <button onClick={() => setKpPanelOpen(!kpPanelOpen)} className={`text-red-600 font-bold text-xs px-2 py-1 rounded border transition-colors ${kpPanelOpen ? 'bg-red-600 text-white border-red-600' : 'bg-red-50 border-red-100 hover:bg-red-100'}`}>
                ğŸ‘‘ KP
              </button>
              <button onClick={undo} disabled={history.length === 0} className="text-orange-600 font-bold text-xs bg-orange-50 px-2 py-1 rounded border border-orange-100 disabled:opacity-40 hover:bg-orange-100 hidden sm:block">â†©ï¸ æ’¤é”€</button>
              <button onClick={() => setView('setup')} className="text-gray-500 text-xs hover:text-black underline">è®¾ç½®</button>
              <button onClick={() => setDrawerOpen(true)} className="text-blue-600 font-bold text-xs bg-blue-50 px-2 py-1 rounded border border-blue-100 hover:bg-blue-100">ğŸ¥</button>
            </>
          )}
        </div>
      </header>

      <main className="flex-1 overflow-hidden relative">
        {view === 'setup' ? (
          <SetupModule characters={characters} setCharacters={setCharacters} updateChar={updateChar} />
        ) : (
          <CombatModule 
            characters={characters} 
            combatOrder={combatOrder}
            updateChar={updateChar}
            turn={turn} 
            setTurn={setTurn}
            logs={logs}
            addLog={addLog}
            currentActor={currentActor}
            isManualDice={isManualDice}
            startNewRound={startNewRound}
            saveToHistory={saveToHistory}
            logContainerRef={logContainerRef}
          />
        )}
        <MedicalDrawer isOpen={drawerOpen} onClose={() => setDrawerOpen(false)} characters={characters} updateChar={updateChar} addLog={addLog} />
        
        <KPControlPanel 
          isOpen={kpPanelOpen} 
          onClose={() => setKpPanelOpen(false)}
          characters={characters}
          updateChar={updateChar}
          addLog={addLog}
          currentActor={currentActor}
        />
      </main>
    </div>
  );
}

// ... KPControlPanel ä¿æŒä¸å˜ ...
function KPControlPanel({ isOpen, onClose, characters, updateChar, addLog, currentActor }) {
  const [selectedCharId, setSelectedCharId] = useState('');
  const [editMode, setEditMode] = useState('stats');
  const [newWeapon, setNewWeapon] = useState({ name: '', damage: '1D6', type: 'melee', impale: false, range: 1 });
  const [newSkill, setNewSkill] = useState({ name: '', description: '', type: 'single_attack' });

  const selectedChar = characters.find(c => c.id === selectedCharId) || currentActor;

  useEffect(() => {
    if (isOpen && !selectedCharId && currentActor) {
      setSelectedCharId(currentActor.id);
    }
  }, [isOpen, currentActor, selectedCharId]);

  const handleStatChange = (field, value) => {
    if (selectedChar) {
      updateChar(selectedChar.id, { [field]: value });
      addLog(`ğŸ‘‘ KPä¿®æ”¹${selectedChar.name}çš„${field}: ${value}`, 'system');
    }
  };

  const addWeaponToChar = () => {
    if (!selectedChar || !newWeapon.name) return;
    const weapons = [...(selectedChar.weapons || []), { ...newWeapon, id: generateId() }];
    updateChar(selectedChar.id, { weapons });
    addLog(`ğŸ‘‘ KPä¸º${selectedChar.name}æ·»åŠ æ­¦å™¨: ${newWeapon.name}`, 'system');
    setNewWeapon({ name: '', damage: '1D6', type: 'melee', impale: false, range: 1 });
  };

  const setActiveWeapon = (weapon) => {
    if (selectedChar) {
      updateChar(selectedChar.id, { activeWeapon: weapon });
      addLog(`ğŸ‘‘ KPåˆ‡æ¢${selectedChar.name}çš„æ­¦å™¨: ${weapon.name}`, 'system');
    }
  };

  const removeWeapon = (weaponId) => {
    if (selectedChar) {
      const weapons = selectedChar.weapons?.filter(w => w.id !== weaponId) || [];
      updateChar(selectedChar.id, { weapons });
      addLog(`ğŸ‘‘ KPç§»é™¤${selectedChar.name}çš„æ­¦å™¨`, 'system');
    }
  };

  const addCustomSkill = () => {
    if (!selectedChar || !newSkill.name) return;
    const customSkills = [...(selectedChar.customSkills || []), { ...newSkill, id: generateId() }];
    updateChar(selectedChar.id, { customSkills });
    addLog(`ğŸ‘‘ KPä¸º${selectedChar.name}æ·»åŠ æŠ€èƒ½: ${newSkill.name}`, 'system');
    setNewSkill({ name: '', description: '', type: 'single_attack' });
  };

  const removeCustomSkill = (skillId) => {
    if (selectedChar) {
      const customSkills = selectedChar.customSkills?.filter(s => s.id !== skillId) || [];
      updateChar(selectedChar.id, { customSkills });
      addLog(`ğŸ‘‘ KPç§»é™¤${selectedChar.name}çš„æŠ€èƒ½`, 'system');
    }
  };

  const quickActions = {
    heal: (amount) => {
      if (selectedChar) {
        const newHp = Math.min(selectedChar.maxHp, selectedChar.hp + amount);
        updateChar(selectedChar.id, { hp: newHp });
        addLog(`ğŸ‘‘ KPæ²»ç–—${selectedChar.name}: +${amount}HP`, 'system');
      }
    },
    damage: (amount) => {
      if (selectedChar) {
        const newHp = Math.max(0, selectedChar.hp - amount);
        updateChar(selectedChar.id, { hp: newHp });
        addLog(`ğŸ‘‘ KPä¼¤å®³${selectedChar.name}: -${amount}HP`, 'system');
      }
    },
    toggleStatus: (status) => {
      if (selectedChar) {
        const newStatus = { ...selectedChar.status, [status]: !selectedChar.status[status] };
        updateChar(selectedChar.id, { status: newStatus });
        addLog(`ğŸ‘‘ KPåˆ‡æ¢${selectedChar.name}çŠ¶æ€: ${status}`, 'system');
      }
    }
  };

  return (
    <div className={`kp-panel ${isOpen ? 'open' : ''}`}>
      <div className="p-4 bg-red-600 text-white flex justify-between items-center">
        <h2 className="font-bold text-lg">ğŸ‘‘ KPæ§åˆ¶å°</h2>
        <button onClick={onClose} className="text-white text-2xl hover:bg-red-700 w-8 h-8 rounded flex items-center justify-center">Ã—</button>
      </div>

      <div className="p-4">
        <div className="mb-6">
          <label className="block text-sm font-bold text-gray-700 mb-2">é€‰æ‹©è§’è‰²</label>
          <select 
            value={selectedCharId} 
            onChange={(e) => setSelectedCharId(e.target.value)}
            className="w-full border rounded px-3 py-2 text-sm"
          >
            {characters.map(c => (
              <option key={c.id} value={c.id}>{c.name} ({c.type === 'player' ? 'è°ƒæŸ¥å‘˜' : 'æ•Œäºº'})</option>
            ))}
          </select>
        </div>

        {selectedChar && (
          <>
            <div className="flex mb-4 border-b">
              {[
                { key: 'stats', label: 'å±æ€§' },
                { key: 'weapons', label: 'æ­¦å™¨' },
                { key: 'skills', label: 'æŠ€èƒ½' }
              ].map(mode => (
                <button
                  key={mode.key}
                  onClick={() => setEditMode(mode.key)}
                  className={`px-4 py-2 text-sm font-bold border-b-2 transition-colors ${
                    editMode === mode.key 
                      ? 'border-red-500 text-red-600' 
                      : 'border-transparent text-gray-500 hover:text-gray-700'
                  }`}
                >
                  {mode.label}
                </button>
              ))}
            </div>

            {editMode === 'stats' && (
              <div className="space-y-6">
                <div>
                  <h3 className="text-sm font-bold text-gray-700 mb-3">å¿«æ·æ“ä½œ</h3>
                  <div className="grid grid-cols-2 gap-2 mb-4">
                    <button onClick={() => quickActions.heal(5)} className="px-3 py-2 bg-green-100 text-green-700 rounded text-sm hover:bg-green-200">æ²»ç–— +5</button>
                    <button onClick={() => quickActions.heal(10)} className="px-3 py-2 bg-green-100 text-green-700 rounded text-sm hover:bg-green-200">æ²»ç–— +10</button>
                    <button onClick={() => quickActions.damage(5)} className="px-3 py-2 bg-red-100 text-red-700 rounded text-sm hover:bg-red-200">ä¼¤å®³ -5</button>
                    <button onClick={() => quickActions.damage(10)} className="px-3 py-2 bg-red-100 text-red-700 rounded text-sm hover:bg-red-200">ä¼¤å®³ -10</button>
                  </div>
                  
                  <div className="grid grid-cols-2 gap-2 mb-4">
                    {[
                      { key: 'majorWound', label: 'é‡ä¼¤' },
                      { key: 'dying', label: 'æ¿’æ­»' },
                      { key: 'unconscious', label: 'æ˜è¿·' },
                      { key: 'prone', label: 'å€’åœ°' }
                    ].map(status => (
                      <button
                        key={status.key}
                        onClick={() => quickActions.toggleStatus(status.key)}
                        className={`px-3 py-2 text-sm rounded transition-colors ${
                          selectedChar.status[status.key]
                            ? 'bg-red-200 text-red-800 hover:bg-red-300'
                            : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                        }`}
                      >
                        {status.label} {selectedChar.status[status.key] ? 'âœ“' : ''}
                      </button>
                    ))}
                  </div>
                </div>

                <div>
                  <h3 className="text-sm font-bold text-gray-700 mb-3">åŸºç¡€å±æ€§</h3>
                  <div className="grid grid-cols-2 gap-3">
                    {[
                      { key: 'str', label: 'STR', min: 1, max: 100 },
                      { key: 'con', label: 'CON', min: 1, max: 100 },
                      { key: 'siz', label: 'SIZ', min: 1, max: 100 },
                      { key: 'dex', label: 'DEX', min: 1, max: 100 },
                      { key: 'hp', label: 'HP', min: 0, max: selectedChar.maxHp }
                    ].map(attr => (
                      <div key={attr.key}>
                        <label className="block text-xs font-bold text-gray-500 mb-1">{attr.label}</label>
                        <input
                          type="number"
                          value={selectedChar[attr.key]}
                          onChange={(e) => handleStatChange(attr.key, parseInt(e.target.value) || 0)}
                          min={attr.min}
                          max={attr.max}
                          className="w-full border rounded px-2 py-1 text-sm"
                        />
                      </div>
                    ))}
                  </div>
                </div>

                <div>
                  <h3 className="text-sm font-bold text-gray-700 mb-3">æŠ€èƒ½</h3>
                  <div className="grid grid-cols-2 gap-3">
                    {[
                      { key: 'fight', label: 'æ ¼æ–—', min: 1, max: 100 },
                      { key: 'firearms', label: 'å°„å‡»', min: 1, max: 100 },
                      { key: 'dodge', label: 'é—ªé¿', min: 1, max: 100 },
                      { key: 'armorValue', label: 'æŠ¤ç”²', min: 0, max: 20 }
                    ].map(skill => (
                      <div key={skill.key}>
                        <label className="block text-xs font-bold text-gray-500 mb-1">{skill.label}</label>
                        <input
                          type="number"
                          value={selectedChar[skill.key]}
                          onChange={(e) => handleStatChange(skill.key, parseInt(e.target.value) || 0)}
                          min={skill.min}
                          max={skill.max}
                          className="w-full border rounded px-2 py-1 text-sm"
                        />
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}

            {editMode === 'weapons' && (
              <div className="space-y-4">
                <div>
                  <h3 className="text-sm font-bold text-gray-700 mb-2">å½“å‰æ­¦å™¨</h3>
                  <div className="weapon-card active">
                    <div className="font-bold">{selectedChar.activeWeapon?.name}</div>
                    <div className="text-sm text-gray-600">ä¼¤å®³: {selectedChar.activeWeapon?.damage}</div>
                    <div className="text-xs text-gray-500">{selectedChar.activeWeapon?.impale ? 'å¯è´¯ç©¿' : 'éè´¯ç©¿'}</div>
                  </div>
                </div>
                <div>
                  <h3 className="text-sm font-bold text-gray-700 mb-2">æ­¦å™¨åº“</h3>
                  <div className="max-h-40 overflow-y-auto">
                    {selectedChar.weapons?.map(weapon => (
                      <div key={weapon.id} className="weapon-card">
                        <div className="flex justify-between items-start">
                          <div className="flex-1">
                            <div className="font-bold">{weapon.name}</div>
                            <div className="text-sm text-gray-600">ä¼¤å®³: {weapon.damage}</div>
                            <div className="text-xs text-gray-500">{weapon.impale ? 'å¯è´¯ç©¿' : 'éè´¯ç©¿'}</div>
                          </div>
                          <div className="flex gap-1">
                            <button 
                              onClick={() => setActiveWeapon(weapon)}
                              className="px-2 py-1 bg-blue-100 text-blue-600 rounded text-xs hover:bg-blue-200"
                            >
                              è£…å¤‡
                            </button>
                            <button 
                              onClick={() => removeWeapon(weapon.id)}
                              className="px-2 py-1 bg-red-100 text-red-600 rounded text-xs hover:bg-red-200"
                            >
                              åˆ é™¤
                            </button>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>

                <div>
                  <h3 className="text-sm font-bold text-gray-700 mb-2">æ·»åŠ é¢„è®¾æ­¦å™¨</h3>
                  <select 
                    onChange={(e) => {
                      const preset = WEAPON_PRESETS.find(w => w.name === e.target.value);
                      if (preset) {
                        const weapons = [...(selectedChar.weapons || []), { ...preset, id: generateId() }];
                        updateChar(selectedChar.id, { weapons });
                        addLog(`ğŸ‘‘ KPä¸º${selectedChar.name}æ·»åŠ æ­¦å™¨: ${preset.name}`, 'system');
                        e.target.value = '';
                      }
                    }}
                    className="w-full border rounded px-3 py-2 text-sm"
                  >
                    <option value="">-- é€‰æ‹©é¢„è®¾æ­¦å™¨ --</option>
                    <optgroup label="è¿‘æˆ˜æ­¦å™¨">
                      {MELEE_WEAPONS.map(w => <option key={w.name} value={w.name}>{w.name}</option>)}
                    </optgroup>
                    <optgroup label="è¿œç¨‹æ­¦å™¨">
                      {RANGED_WEAPONS.map(w => <option key={w.name} value={w.name}>{w.name}</option>)}
                    </optgroup>
                  </select>
                </div>

                <div>
                  <h3 className="text-sm font-bold text-gray-700 mb-2">è‡ªå®šä¹‰æ­¦å™¨</h3>
                  <div className="space-y-2">
                    <input
                      type="text"
                      placeholder="æ­¦å™¨åç§°"
                      value={newWeapon.name}
                      onChange={(e) => setNewWeapon({...newWeapon, name: e.target.value})}
                      className="w-full border rounded px-3 py-2 text-sm"
                    />
                    <input
                      type="text"
                      placeholder="ä¼¤å®³ (å¦‚: 1D8+2)"
                      value={newWeapon.damage}
                      onChange={(e) => setNewWeapon({...newWeapon, damage: e.target.value})}
                      className="w-full border rounded px-3 py-2 text-sm"
                    />
                    <div className="flex gap-2">
                      <select 
                        value={newWeapon.type} 
                        onChange={(e) => setNewWeapon({...newWeapon, type: e.target.value})}
                        className="flex-1 border rounded px-3 py-2 text-sm"
                      >
                        <option value="melee">è¿‘æˆ˜</option>
                        <option value="ranged">è¿œç¨‹</option>
                      </select>
                      <label className="flex items-center gap-1 text-sm">
                        <input
                          type="checkbox"
                          checked={newWeapon.impale}
                          onChange={(e) => setNewWeapon({...newWeapon, impale: e.target.checked})}
                        />
                        è´¯ç©¿
                      </label>
                    </div>
                    <button 
                      onClick={addWeaponToChar}
                      className="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700"
                    >
                      æ·»åŠ æ­¦å™¨
                    </button>
                  </div>
                </div>
              </div>
            )}

            {editMode === 'skills' && (
              <div className="space-y-4">
                <div>
                  <h3 className="text-sm font-bold text-gray-700 mb-2">è‡ªå®šä¹‰æŠ€èƒ½</h3>
                  <div className="max-h-40 overflow-y-auto">
                    {selectedChar.customSkills?.map(skill => (
                      <div key={skill.id} className={`skill-item ${skill.type === 'multi_attack' ? 'multi-target' : ''}`}>
                        <div className="flex-1">
                          <div className="font-bold">{skill.name}</div>
                          <div className="text-xs text-gray-600">{skill.description}</div>
                          <div className="text-xs text-gray-500">ç±»å‹: {skill.type}</div>
                        </div>
                        <button 
                          onClick={() => removeCustomSkill(skill.id)}
                          className="text-red-500 hover:text-red-700 text-sm font-bold"
                        >
                          Ã—
                        </button>
                      </div>
                    ))}
                  </div>
                </div>

                <div>
                  <h3 className="text-sm font-bold text-gray-700 mb-2">æŠ€èƒ½æ¨¡æ¿</h3>
                  <div className="grid grid-cols-1 gap-2">
                    {SKILL_TEMPLATES.map(template => (
                      <button
                        key={template.id}
                        onClick={() => {
                          const customSkills = [...(selectedChar.customSkills || []), { ...template, id: generateId() }];
                          updateChar(selectedChar.id, { customSkills });
                          addLog(`ğŸ‘‘ KPä¸º${selectedChar.name}æ·»åŠ æŠ€èƒ½: ${template.name}`, 'system');
                        }}
                        className="p-2 border rounded text-left text-sm hover:bg-gray-50"
                      >
                        <div className="font-bold">{template.name}</div>
                        <div className="text-xs text-gray-600">{template.description}</div>
                      </button>
                    ))}
                  </div>
                </div>

                <div>
                  <h3 className="text-sm font-bold text-gray-700 mb-2">åˆ›å»ºæŠ€èƒ½</h3>
                  <div className="space-y-2">
                    <input
                      type="text"
                      placeholder="æŠ€èƒ½åç§°"
                      value={newSkill.name}
                      onChange={(e) => setNewSkill({...newSkill, name: e.target.value})}
                      className="w-full border rounded px-3 py-2 text-sm"
                    />
                    <textarea
                      placeholder="æŠ€èƒ½æè¿°"
                      value={newSkill.description}
                      onChange={(e) => setNewSkill({...newSkill, description: e.target.value})}
                      className="w-full border rounded px-3 py-2 text-sm"
                      rows={2}
                    />
                    <select 
                      value={newSkill.type} 
                      onChange={(e) => setNewSkill({...newSkill, type: e.target.value})}
                      className="w-full border rounded px-3 py-2 text-sm"
                    >
                      <option value="single_attack">å•ä½“æ”»å‡»</option>
                      <option value="multi_attack">ç¾¤ä½“æ”»å‡»</option>
                      <option value="buff">å¢ç›Š</option>
                      <option value="debuff">å‡ç›Š</option>
                    </select>
                    <button 
                      onClick={addCustomSkill}
                      className="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700"
                    >
                      åˆ›å»ºæŠ€èƒ½
                    </button>
                  </div>
                </div>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
}

// ... SetupModule ä¿æŒä¸å˜ï¼ŒCSSå·²ç»ä¿®å¤äº†å®ƒçš„å¸ƒå±€ ...
function SetupModule({ characters, setCharacters, updateChar }) {
  const [selectedId, setSelectedId] = useState(null);
  const [importText, setImportText] = useState('');
  const [isImporting, setIsImporting] = useState(false);
  const activeChar = characters.find(c => c.id === selectedId);

  const addCharacter = (type) => {
    const newChar = { 
      ...JSON.parse(JSON.stringify(BASE_CHARACTER)), 
      id: generateId(), 
      type, 
      name: type === 'player' ? 'æ–°è°ƒæŸ¥å‘˜' : 'æ–°æ•Œäºº',
      weapons: [], 
      customSkills: [] 
    };
    const derived = calcDerived(newChar);
    setCharacters(p => [...p, { ...newChar, ...derived, hp: derived.maxHp }]);
    setSelectedId(newChar.id);
  };

  const handleImport = () => {
    if (!importText) return;
    const lines = importText.split('\n');
    const newChar = { ...JSON.parse(JSON.stringify(BASE_CHARACTER)), id: generateId(), type: 'player', name: 'å¯¼å…¥è§’è‰²', weapons: [], customSkills: [] };
    lines.forEach(line => {
      if (line.includes('åŠ›é‡')) newChar.str = parseInt(line.match(/åŠ›é‡\s*(\d+)/)?.[1] || 50);
      if (line.includes('ä½“è´¨')) newChar.con = parseInt(line.match(/ä½“è´¨\s*(\d+)/)?.[1] || 50);
      if (line.includes('ä½“å‹')) newChar.siz = parseInt(line.match(/ä½“å‹\s*(\d+)/)?.[1] || 60);
      if (line.includes('æ•æ·')) newChar.dex = parseInt(line.match(/æ•æ·\s*(\d+)/)?.[1] || 50);
      if (line.includes('æ–—æ®´') || line.includes('æ ¼æ–—')) newChar.fight = parseInt(line.match(/\d+/)?.[0] || 50);
      if (line.includes('å°„å‡»')) newChar.firearms = parseInt(line.match(/\d+/)?.[0] || 20);
      if (line.includes('é—ªé¿')) newChar.dodge = parseInt(line.match(/\d+/)?.[0] || 25);
    });
    const derived = calcDerived(newChar);
    setCharacters(p => [...p, { ...newChar, ...derived, hp: derived.maxHp }]);
    setSelectedId(newChar.id);
    setImportText('');
    setIsImporting(false);
  };

  return (
    <div className="setup-grid flex h-full divide-x divide-gray-200">
      <div className="setup-sidebar w-64 bg-gray-50 flex flex-col shrink-0 h-full overflow-hidden panel-scroll panel-left">
        <div className="p-3 space-y-4">
          {isImporting ? (
            <div className="bg-white p-2 rounded border border-gray-300 shadow-sm">
              <textarea className="w-full h-24 text-xs font-mono border border-gray-200 rounded p-1 mb-2 focus:ring-1 focus:ring-gray-400 outline-none" placeholder="ç²˜è´´ .st æ–‡æœ¬..." value={importText} onChange={e => setImportText(e.target.value)} />
              <div className="flex gap-2">
                <button onClick={handleImport} className="flex-1 bg-gray-900 text-white text-xs py-1 rounded hover:bg-gray-800">ç¡®è®¤</button>
                <button onClick={() => setIsImporting(false)} className="flex-1 bg-gray-200 text-xs py-1 rounded hover:bg-gray-300">å–æ¶ˆ</button>
              </div>
            </div>
          ) : (
            <button onClick={() => setIsImporting(true)} className="w-full py-2 border border-dashed border-gray-300 text-gray-400 text-xs rounded hover:border-gray-900 hover:text-gray-900 transition-colors">ğŸ“¥ ç²˜è´´ .st å¯¼å…¥</button>
          )}
          <div>
            <div className="flex justify-between items-center mb-2">
              <h3 className="text-xs font-bold text-gray-500 uppercase">è°ƒæŸ¥å‘˜</h3>
              <button onClick={() => addCharacter('player')} className="text-blue-600 text-xs font-bold hover:bg-blue-50 px-2 rounded">+</button>
            </div>
            <div className="space-y-1">
              {characters.filter(c => c.type === 'player').map(c => (
                <div key={c.id} onClick={() => setSelectedId(c.id)} className={`flex items-center justify-between px-2 py-1.5 rounded cursor-pointer text-xs border transition-colors ${selectedId === c.id ? 'bg-blue-50 border-blue-200 text-blue-700' : 'bg-white border-transparent hover:bg-gray-100'}`}>
                  <span className="font-medium truncate">{c.name}</span>
                  <button onClick={(e) => { e.stopPropagation(); setCharacters(p => p.filter(x => x.id !== c.id)); }} className="text-gray-300 hover:text-red-600">Ã—</button>
                </div>
              ))}
            </div>
          </div>
          <div>
            <div className="flex justify-between items-center mb-2">
              <h3 className="text-xs font-bold text-gray-500 uppercase">å¨èƒ</h3>
              <button onClick={() => addCharacter('enemy')} className="text-red-600 text-xs font-bold hover:bg-red-50 px-2 rounded">+</button>
            </div>
            <div className="space-y-1">
              {characters.filter(c => c.type === 'enemy').map(c => (
                <div key={c.id} onClick={() => setSelectedId(c.id)} className={`flex items-center justify-between px-2 py-1.5 rounded cursor-pointer text-xs border transition-colors ${selectedId === c.id ? 'bg-red-50 border-red-200 text-red-700' : 'bg-white border-transparent hover:bg-gray-100'}`}>
                  <span className="font-medium truncate">{c.name}</span>
                  <button onClick={(e) => { e.stopPropagation(); setCharacters(p => p.filter(x => x.id !== c.id)); }} className="text-gray-300 hover:text-red-600">Ã—</button>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
      <div className="setup-content flex-1 bg-white h-full overflow-y-auto panel-scroll">
        {activeChar ? <CharacterSheet char={activeChar} updateChar={updateChar} /> : (
          <div className="h-full flex items-center justify-center text-gray-300"><div className="text-center"><div className="text-4xl mb-2 opacity-20">ğŸ—‚ï¸</div><p className="text-sm">é€‰æ‹©æˆ–åˆ›å»ºè§’è‰²</p></div></div>
        )}
      </div>
    </div>
  );
}

// ... CharacterSheet ä¿æŒä¸å˜ ...
function CharacterSheet({ char, updateChar }) {
  const Cell = ({ label, value, field, type="number", readonly=false }) => (
    <div className="flex flex-col">
      <label className="text-[10px] uppercase text-gray-400 font-bold mb-0.5">{label}</label>
      <input type={type} value={value} readOnly={readonly} onChange={(e) => updateChar(char.id, { [field]: type === 'number' ? parseInt(e.target.value)||0 : e.target.value })} className={`w-full py-0.5 bg-transparent border-b border-gray-200 text-sm font-mono focus:outline-none focus:border-gray-900 transition-colors ${readonly ? 'text-gray-400 cursor-not-allowed border-dashed' : 'text-gray-900'}`} />
    </div>
  );

  return (
    <div className="max-w-2xl mx-auto p-6">
      <div className="mb-6 flex gap-4 items-end">
        <div className="flex-1"><input type="text" value={char.name} onChange={e => updateChar(char.id, { name: e.target.value })} className="text-2xl font-bold w-full border-b-2 border-gray-900 pb-1 focus:outline-none" placeholder="NAME" /></div>
        <div className="w-28"><label className="text-xs font-bold text-gray-400">TYPE</label><select value={char.type} onChange={e => updateChar(char.id, { type: e.target.value })} className="w-full py-1 bg-transparent border-b border-gray-200 text-sm focus:outline-none"><option value="player">PLAYER</option><option value="enemy">ENEMY</option></select></div>
      </div>
      
      <div className="grid grid-cols-2 sm:grid-cols-4 gap-x-4 sm:gap-x-6 gap-y-4 mb-6">
        <Cell label="STR" field="str" value={char.str} />
        <Cell label="CON" field="con" value={char.con} />
        <Cell label="SIZ" field="siz" value={char.siz} />
        <Cell label="DEX" field="dex" value={char.dex} />
        <Cell label="HP(Max)" field="maxHp" value={char.maxHp} readonly />
        <Cell label="DB" field="db" value={char.db} type="text" readonly />
        <Cell label="Build" field="build" value={char.build} readonly />
        <Cell label="MOV" field="mov" value={char.mov} readonly />
        <Cell label="æ ¼æ–—" field="fight" value={char.fight} />
        <Cell label="é—ªé¿" field="dodge" value={char.dodge} />
        <Cell label="å°„å‡»" field="firearms" value={char.firearms} />
        <Cell label="æŠ¤ç”²" field="armorValue" value={char.armorValue || 0} />
      </div>
      
      <div className="mb-4"><label className="flex items-center gap-2 cursor-pointer text-sm select-none"><input type="checkbox" checked={char.hasGunReady || false} onChange={e => updateChar(char.id, { hasGunReady: e.target.checked })} className="w-4 h-4" /><span>ğŸ”« æªæ¢°å·²å‡†å¤‡ (DEX+50)</span></label></div>
      
      <div className="border-t border-gray-200 pt-4">
        <h4 className="text-xs font-bold text-gray-900 uppercase mb-3">æ­¦å™¨é…ç½®</h4>
        <div className="grid grid-cols-2 sm:grid-cols-4 gap-3 bg-gray-50 p-3 rounded border border-gray-200">
          <div className="col-span-2">
            <label className="text-[10px] uppercase text-gray-400 font-bold mb-1 block">é¢„è®¾</label>
            <select className="w-full text-xs bg-white border border-gray-200 rounded py-1 px-2 focus:ring-1 focus:ring-black outline-none" value={char.activeWeapon?.name || ''} onChange={(e) => { const p = WEAPON_PRESETS.find(w => w.name === e.target.value); if (p) updateChar(char.id, { activeWeapon: { ...char.activeWeapon, ...p } }); }}>
              <option value="">-- é€‰æ‹© --</option>
              <optgroup label="è¿‘æˆ˜">{MELEE_WEAPONS.map(w => <option key={w.name} value={w.name}>{w.name}</option>)}</optgroup>
              <optgroup label="è¿œç¨‹">{RANGED_WEAPONS.map(w => <option key={w.name} value={w.name}>{w.name}</option>)}</optgroup>
            </select>
          </div>
          <div><label className="text-[10px] uppercase text-gray-400 font-bold mb-1 block">ä¼¤å®³</label><div className="text-xs font-mono py-1">{char.activeWeapon?.damage || '1D3'}</div></div>
          <div><label className="text-[10px] uppercase text-gray-400 font-bold mb-1 block">ç±»å‹</label><div className={`text-xs py-1 ${char.activeWeapon?.impale ? 'text-red-600' : 'text-gray-500'}`}>{char.activeWeapon?.impale ? 'å¯è´¯ç©¿' : 'éè´¯ç©¿'}</div></div>
        </div>
      </div>

      {char.weapons && char.weapons.length > 0 && (
        <div className="border-t border-gray-200 pt-4 mt-4">
          <h4 className="text-xs font-bold text-gray-900 uppercase mb-3">æ­¦å™¨åº“ ({char.weapons.length})</h4>
          <div className="space-y-2">
            {char.weapons.slice(0, 3).map(weapon => (
              <div key={weapon.id} className="flex items-center justify-between p-2 bg-gray-50 rounded text-xs">
                <div>
                  <span className="font-bold">{weapon.name}</span>
                  <span className="text-gray-500 ml-2">{weapon.damage}</span>
                </div>
                <button 
                  onClick={() => updateChar(char.id, { activeWeapon: weapon })}
                  className="text-blue-600 hover:text-blue-800"
                >
                  è£…å¤‡
                </button>
              </div>
            ))}
            {char.weapons.length > 3 && (
              <div className="text-xs text-gray-500 text-center">è¿˜æœ‰ {char.weapons.length - 3} ä»¶æ­¦å™¨...</div>
            )}
          </div>
        </div>
      )}

      {char.customSkills && char.customSkills.length > 0 && (
        <div className="border-t border-gray-200 pt-4 mt-4">
          <h4 className="text-xs font-bold text-gray-900 uppercase mb-3">ç‰¹æ®ŠæŠ€èƒ½ ({char.customSkills.length})</h4>
          <div className="space-y-2">
            {char.customSkills.slice(0, 3).map(skill => (
              <div key={skill.id} className={`p-2 rounded text-xs ${skill.type === 'multi_attack' ? 'bg-yellow-50 border border-yellow-200' : 'bg-gray-50'}`}>
                <div className="font-bold">{skill.name}</div>
                <div className="text-gray-600">{skill.description}</div>
              </div>
            ))}
            {char.customSkills.length > 3 && (
              <div className="text-xs text-gray-500 text-center">è¿˜æœ‰ {char.customSkills.length - 3} ä¸ªæŠ€èƒ½...</div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}

// ... CombatModule é€»è¾‘ä¸å˜ï¼Œç»“æ„å¾®è°ƒä»¥é€‚åº” CSS ...
function CombatModule({ characters, combatOrder, updateChar, turn, setTurn, logs, addLog, currentActor, isManualDice, startNewRound, saveToHistory, logContainerRef }) {
  const [phase, setPhase] = useState('select_action');
  const [selectedTargetId, setSelectedTargetId] = useState(null);
  const [selectedTargetIds, setSelectedTargetIds] = useState([]);
  const [combatAction, setCombatAction] = useState(null);
  const [maneuverType, setManeuverType] = useState('knockdown');
  const [shootingDistance, setShootingDistance] = useState(10);
  const [inputValue, setInputValue] = useState('');
  const [selectedCustomSkill, setSelectedCustomSkill] = useState(null);
  const [mobileTab, setMobileTab] = useState('action');

  const targetActor = combatOrder.find(c => c.id === selectedTargetId);
  const selectedTargets = combatOrder.filter(c => selectedTargetIds.includes(c.id));

  useEffect(() => {
    if (!currentActor) return;
    const hostiles = combatOrder.filter(c => c.id !== currentActor.id && c.hp > 0 && c.type !== currentActor.type);
    setSelectedTargetId(hostiles.length > 0 ? hostiles[0].id : (combatOrder.find(c => c.id !== currentActor.id && c.hp > 0)?.id || null));
  }, [currentActor?.id, combatOrder]);

  useEffect(() => {
    if (isManualDice) return;
    const autoPhases = ['input_roll', 'input_defense_roll', 'input_damage'];
    if (!autoPhases.includes(phase)) return;
    if (phase === 'input_damage') {
      if (!combatAction || !combatAction.damageAttacker) return;
    } else {
      if (!combatAction) return;
    }

    let val;
    if (phase === 'input_damage') {
      const atk = combatAction.damageAttacker;
      if (!atk || !atk.activeWeapon) return;
      const dmgResult = calculateDamage(atk.activeWeapon, atk, combatAction.damageSuccessLevel || 1, !!combatAction.isCounterAttack);
      val = dmgResult.total;
    } else {
      val = Math.floor(Math.random() * 100) + 1;
    }
    
    setInputValue(String(val));
    const timer = setTimeout(() => {
      if (isManualDice) return;
      if (phase === 'input_damage') handleDmg(); else handleRoll();
    }, 600);
    return () => clearTimeout(timer);
  }, [phase, isManualDice, combatAction]);

  const nextTurn = () => {
    setPhase('select_action'); setCombatAction(null); setInputValue(''); setSelectedCustomSkill(null); setSelectedTargetIds([]);
    let next = (turn.index + 1) % combatOrder.length;
    let tries = 0;
    while (combatOrder[next].hp <= 0 && tries < combatOrder.length) { next = (next + 1) % combatOrder.length; tries++; }
    const nextRound = next <= turn.index ? turn.round + 1 : turn.round;
    if (nextRound > turn.round) { addLog(`\nâš”ï¸ ç¬¬${nextRound}è½®å¼€å§‹ï¼`, "system"); startNewRound(); }
    setTurn({ index: next, round: nextRound });
    addLog(`ğŸ‘¤ è½®åˆ° ${combatOrder[next].name} è¡ŒåŠ¨`, "system");
  };

  const applyDamage = (target, dmg) => {
    const final = Math.max(0, dmg - (target.armorValue || 0));
    const newHp = Math.max(0, target.hp - final);
    let status = { ...target.status };
    if (final >= Math.ceil(target.maxHp / 2) && !target.status.majorWound) { 
      status.majorWound = true; 
      status.prone = true; 
      addLog(`ğŸš¨ ${target.name} é‡ä¼¤å€’åœ°ï¼`, 'damage'); 
    }
    if (newHp <= 0) { 
      if (status.majorWound) { 
        status.dying = true; 
        addLog(`ğŸ’€ ${target.name} æ¿’æ­»ï¼`, 'damage'); 
      } else { 
        status.unconscious = true; 
        addLog(`ğŸ˜´ ${target.name} æ˜è¿·`, 'damage'); 
      }
    } else { 
      addLog(`â¤ï¸ ${target.name} HP: ${newHp}/${target.maxHp}`, 'info'); 
    }
    updateChar(target.id, { hp: newHp, status });
  };

  const handleMultiTargetAttack = (customSkill) => {
    if (selectedTargets.length === 0) {
      addLog("âŒ æœªé€‰æ‹©ç›®æ ‡", "error");
      return;
    }
    saveToHistory();
    const ammoCost = customSkill.baseCost * selectedTargets.length;
    if (currentActor.activeWeapon.type === 'ranged' && currentActor.activeWeapon.ammo < ammoCost) {
      addLog("âŒ å¼¹è¯ä¸è¶³", "error");
      return;
    }
    const results = calculateMultiTargetAttack(currentActor.firearms, currentActor.activeWeapon, selectedTargets, customSkill);
    if (currentActor.activeWeapon.type === 'ranged') {
      const newAmmo = currentActor.activeWeapon.ammo - ammoCost;
      updateChar(currentActor.id, { activeWeapon: { ...currentActor.activeWeapon, ammo: newAmmo } });
    }
    addLog(`ğŸ¯ ${currentActor.name} ä½¿ç”¨ ${customSkill.name}`, "system");
    results.forEach(result => {
      if (result.hit) {
        addLog(`âœ… å‘½ä¸­ ${result.target.name}: ${result.damage} ä¼¤å®³`, "damage");
        applyDamage(result.target, result.damage);
      } else {
        addLog(`âŒ æœªå‘½ä¸­ ${result.target.name}`, "info");
      }
    });
    nextTurn();
  };

  const handleCommit = (type) => {
    if (type === 'custom_skill') {
      if (!selectedCustomSkill) { addLog("âŒ æœªé€‰æ‹©æŠ€èƒ½", "error"); return; }
      if (selectedCustomSkill.type === 'multi_attack') { handleMultiTargetAttack(selectedCustomSkill); return; }
    }
    if (!selectedTargetId && type !== 'custom_skill') { addLog("âŒ æœªé€‰ç›®æ ‡", "error"); return; }
    
    saveToHistory();
    
    if (type === 'melee') {
      setCombatAction({ type, attacker: currentActor, target: targetActor, weapon: currentActor.activeWeapon });
      addLog(`âš”ï¸ ${currentActor.name} æ”»å‡» ${targetActor.name}`, "system");
      setPhase('waiting_defense');
    } else if (type === 'ranged') {
      const w = currentActor.activeWeapon;
      if (w.type !== 'ranged' || (w.ammo||0) <= 0) return addLog("âŒ æ— æ³•å°„å‡»", "error");
      let diff = 'regular', txt = 'å¸¸è§„';
      if (shootingDistance > w.range * 4) return addLog("âŒ è¶…å‡ºå°„ç¨‹", "error");
      if (shootingDistance > w.range * 2) { diff = 'extreme'; txt = 'æéš¾'; }
      else if (shootingDistance > w.range) { diff = 'hard'; txt = 'å›°éš¾'; }
      setCombatAction({ type, attacker: currentActor, target: targetActor, weapon: w, distance: shootingDistance, difficulty: diff });
      updateChar(currentActor.id, { activeWeapon: { ...w, ammo: w.ammo - 1 } });
      addLog(`ğŸ”« ${currentActor.name} å°„å‡» ${targetActor.name} (${txt})`, "system");
      setPhase('input_roll');
    } else if (type === 'maneuver') {
      const buildDiff = targetActor.build - currentActor.build;
      if (buildDiff >= 3) return addLog("âŒ ä½“æ ¼å·®è·è¿‡å¤§", "error");
      setCombatAction({ type, attacker: currentActor, target: targetActor, maneuverType, penaltyDice: Math.max(0, buildDiff) });
      addLog(`ğŸ¤¼ ${currentActor.name} å¯¹ ${targetActor.name} æ–½å±•æˆ˜æŠ€`, "system");
      setPhase('waiting_defense');
    }
  };

  const handleRoll = () => {
    const roll = parseInt(inputValue) || 0;
    if (roll < 1 || roll > 100) return;

    const { type, attacker, target } = combatAction;
    let skill = type === 'ranged' ? attacker.firearms : type === 'maneuver' ? attacker.fight : combatAction.attackerSkill;
    if (type === 'ranged' && combatAction.difficulty === 'hard') skill = Math.floor(skill / 2);
    if (type === 'ranged' && combatAction.difficulty === 'extreme') skill = Math.floor(skill / 5);

    const successLevel = calculateSuccessLevel(roll, skill);
    const label = getSuccessLabel(successLevel);
    addLog(`ğŸ² ${attacker.name} æ·éª°: ${roll}/${skill} â†’ ${label}`, "roll");

    if (type === 'ranged' || type === 'maneuver') {
      if (successLevel > 0) {
        if (type === 'ranged') {
          setCombatAction(p => ({ ...p, hitSuccessLevel: successLevel, damageAttacker: attacker, damageSuccessLevel: successLevel }));
          setPhase('input_damage');
        } else {
          addLog(`âœ… æˆ˜æŠ€æˆåŠŸï¼${target.name} è¢«${maneuverType === 'knockdown' ? 'å‡»å€’' : maneuverType === 'disarm' ? 'ç¼´æ¢°' : maneuverType === 'grapple' ? 'å‹åˆ¶' : 'æ¨æ’'}`, "success");
          const statusUpdate = {};
          if (maneuverType === 'knockdown') statusUpdate.prone = true;
          updateChar(target.id, { status: { ...target.status, ...statusUpdate } });
          nextTurn();
        }
      } else {
        addLog(`âŒ ${type === 'ranged' ? 'å°„å‡»' : 'æˆ˜æŠ€'}å¤±è´¥`, "info");
        nextTurn();
      }
    } else {
      setCombatAction(p => ({ ...p, attackerRoll: roll, attackerSuccessLevel: successLevel }));
      updateChar(target.id, { status: { ...target.status, defenseUsedThisRound: true } });
      setPhase('input_defense_roll');
      setInputValue('');
    }
  };

  const handleDefenseRoll = () => {
    const defRoll = parseInt(inputValue) || 0;
    if (defRoll < 1 || defRoll > 100) return;
    const { attackerRoll, attackerSuccessLevel, target, defenseType, defenderSkill } = combatAction;
    const defSuccessLevel = calculateSuccessLevel(defRoll, defenderSkill);
    const defLabel = getSuccessLabel(defSuccessLevel);
    addLog(`ğŸ² ${target.name} ${defenseType === 'counter' ? 'åå‡»' : 'é—ªé¿'}: ${defRoll}/${defenderSkill} â†’ ${defLabel}`, "roll");
    const result = executeOpposedCheck(combatAction.attackerSkill, defenderSkill, attackerRoll, defRoll, defenseType);
    if (result.success) {
      const isCounterAttack = defenseType === 'counter' && result.winner === 'defender';
      if (isCounterAttack) {
        addLog(`âš”ï¸ ${target.name} åå‡»æˆåŠŸï¼`, "success");
        setCombatAction(p => ({ ...p, isCounterAttack: true, damageAttacker: target, damageSuccessLevel: Math.min(defSuccessLevel, 2) }));
      } else {
        addLog(`âš”ï¸ ${combatAction.attacker.name} æ”»å‡»å‘½ä¸­ï¼`, "success");
        setCombatAction(p => ({ ...p, damageAttacker: combatAction.attacker, damageSuccessLevel: attackerSuccessLevel }));
      }
      setPhase('input_damage');
    } else {
      addLog(`ğŸ’¨ ${defenseType === 'counter' ? 'åå‡»å¤±è´¥ï¼Œä½†æˆåŠŸæ ¼æŒ¡' : 'é—ªé¿æˆåŠŸ'}`, "info");
      nextTurn();
    }
    setInputValue('');
  };

  const handleDmg = () => {
    const dmg = parseInt(inputValue) || 0;
    const { target, damageAttacker, isCounterAttack } = combatAction;
    const victim = isCounterAttack ? combatAction.attacker : target;
    addLog(`ğŸ’¥ ${damageAttacker.name} å¯¹ ${victim.name} é€ æˆ ${dmg} ä¼¤å®³`, "damage");
    applyDamage(victim, dmg);
    nextTurn();
  };

  const toggleTargetSelection = (targetId) => {
    setSelectedTargetIds(prev => prev.includes(targetId) ? prev.filter(id => id !== targetId) : [...prev, targetId]);
  };

  return (
    <div className="combat-grid">
      <div className={`panel-scroll panel-left p-3 space-y-2 ${mobileTab === 'status' ? 'panel-mobile-active' : ''}`}>
        {combatOrder.map(c => (
          <div key={c.id} className={`p-2 rounded border ${currentActor?.id === c.id ? 'bg-white border-black shadow' : 'bg-white border-gray-200 opacity-80'}`}>
            <div className="flex justify-between text-xs font-bold mb-1">
              <span className={c.type==='player'?'text-blue-700':'text-red-700'}>{c.name}</span>
              <span className="text-gray-400 font-mono">DEX{c.hasGunReady?c.dex+50:c.dex}</span>
            </div>
            <div className="h-1.5 bg-gray-100 rounded-full overflow-hidden mb-1">
              <div className={`h-full ${c.type==='player'?'bg-blue-500':'bg-red-500'}`} style={{width:`${(c.hp/c.maxHp)*100}%`}}/>
            </div>
            <div className="flex justify-between text-[10px] font-mono text-gray-500">
              <span>HP:{c.hp}/{c.maxHp}</span>
              <div className="flex gap-1">
                {c.status.majorWound&&<span className="text-red-600">é‡ä¼¤</span>}
                {c.status.dying&&<span className="bg-black text-white px-1 rounded">æ¿’æ­»</span>}
              </div>
            </div>
            {(c.weapons?.length > 0 || c.customSkills?.length > 0) && (
              <div className="flex gap-1 mt-1">
                {c.weapons?.length > 0 && <span className="text-[9px] bg-gray-200 px-1 rounded">æ­¦å™¨{c.weapons.length}</span>}
                {c.customSkills?.length > 0 && <span className="text-[9px] bg-yellow-200 px-1 rounded">æŠ€èƒ½{c.customSkills.length}</span>}
              </div>
            )}
          </div>
        ))}
      </div>

      <div className={`panel-center ${mobileTab === 'action' ? 'panel-mobile-active' : ''}`}>
        <div className="target-bar p-3">
          <h3 className="text-[10px] font-bold text-gray-400 uppercase mb-2">
            é€‰æ‹©ç›®æ ‡ 
            {selectedCustomSkill?.type === 'multi_attack' && (
              <span className="ml-2 text-yellow-600">å¤šç›®æ ‡æ¨¡å¼ ({selectedTargets.length})</span>
            )}
            {selectedTargetId && targetActor && selectedCustomSkill?.type !== 'multi_attack' && (
              <span className={`ml-2 px-1.5 rounded text-[10px] ${targetActor.type!==currentActor?.type?'bg-red-100 text-red-700':'bg-blue-100 text-blue-700'}`}>
                {targetActor.type!==currentActor?.type?'æ•Œå¯¹':'å‹æ–¹'}
              </span>
            )}
          </h3>
          <div className="flex gap-2 overflow-x-auto pb-1">
            {combatOrder.filter(c => c.id !== currentActor?.id && c.hp > 0).map(t => (
              <button 
                key={t.id} 
                onClick={() => {
                  if (selectedCustomSkill?.type === 'multi_attack') {
                    toggleTargetSelection(t.id);
                  } else {
                    setSelectedTargetId(t.id);
                  }
                }}
                className={`px-2 py-1 border rounded text-xs shrink-0 transition-colors ${
                  selectedCustomSkill?.type === 'multi_attack' 
                    ? (selectedTargetIds.includes(t.id) ? 'border-yellow-500 bg-yellow-100' : 'border-gray-200 bg-white hover:bg-yellow-50')
                    : (selectedTargetId===t.id ? 'border-black bg-white shadow-sm' : t.type!==currentActor?.type ? 'border-red-200 bg-red-50' : 'border-gray-200 bg-white')
                }`}
              >
                <span className="font-bold">{t.name}</span>
                {selectedCustomSkill?.type === 'multi_attack' && selectedTargetIds.includes(t.id) && <span className="ml-1">âœ“</span>}
              </button>
            ))}
          </div>
        </div>

        <div className="action-area">
          <div className="absolute inset-0 flex items-center justify-center pointer-events-none opacity-5"><span className="text-9xl font-black">VS</span></div>
          <div className="centered-card p-5">
            {phase === 'select_action' && (
              <div className="space-y-4">
                <div className="text-center mb-4">
                  <h2 className="text-xl font-bold">{currentActor?.name}</h2>
                  <p className="text-gray-500 text-xs mt-1">{currentActor?.activeWeapon.name}</p>
                  {currentActor?.activeWeapon.ammo !== undefined && (
                    <p className="text-gray-400 text-xs">å¼¹è¯: {currentActor.activeWeapon.ammo}</p>
                  )}
                </div>

                <div className="flex border rounded overflow-hidden shadow-sm">
                  <button onClick={()=>handleCommit('melee')} className="flex-1 py-3 hover:bg-gray-50 font-bold text-sm border-r">âš”ï¸ è¿‘æˆ˜</button>
                  <button onClick={()=>handleCommit('ranged')} className="flex-1 py-3 hover:bg-gray-50 font-bold text-sm border-r">ğŸ”« å°„å‡»</button>
                  <button onClick={()=>setPhase('select_maneuver')} className="flex-1 py-3 hover:bg-gray-50 font-bold text-sm">ğŸ¤¼ æˆ˜æŠ€</button>
                </div>

                {currentActor?.customSkills && currentActor.customSkills.length > 0 && (
                  <div>
                    <h4 className="text-sm font-bold text-gray-600 mb-2">ç‰¹æ®ŠæŠ€èƒ½</h4>
                    <div className="space-y-2 max-h-32 overflow-y-auto">
                      {currentActor.customSkills.map(skill => (
                        <button
                          key={skill.id}
                          onClick={() => {
                            setSelectedCustomSkill(skill);
                            setSelectedTargetIds([]);
                            if (skill.type !== 'multi_attack') {
                              handleCommit('custom_skill');
                            }
                          }}
                          className={`w-full p-2 border rounded text-left text-xs transition-colors ${
                            selectedCustomSkill?.id === skill.id 
                              ? 'border-yellow-500 bg-yellow-50' 
                              : skill.type === 'multi_attack'
                                ? 'border-yellow-200 bg-yellow-50 hover:bg-yellow-100'
                                : 'border-gray-200 bg-gray-50 hover:bg-gray-100'
                          }`}
                        >
                          <div className="font-bold">{skill.name}</div>
                          <div className="text-gray-600">{skill.description}</div>
                          {skill.type === 'multi_attack' && (
                            <div className="text-yellow-600 text-xs mt-1">å¤šç›®æ ‡æ”»å‡»</div>
                          )}
                        </button>
                      ))}
                    </div>
                    {selectedCustomSkill?.type === 'multi_attack' && (
                      <button 
                        onClick={() => handleCommit('custom_skill')}
                        disabled={selectedTargets.length === 0}
                        className="w-full mt-2 bg-yellow-600 text-white py-2 rounded font-bold disabled:opacity-50"
                      >
                        æ‰§è¡Œ {selectedCustomSkill.name} ({selectedTargets.length}ç›®æ ‡)
                      </button>
                    )}
                  </div>
                )}

                {currentActor?.weapons && currentActor.weapons.length > 0 && (
                  <div>
                    <h4 className="text-sm font-bold text-gray-600 mb-2">å¿«é€Ÿåˆ‡æ¢æ­¦å™¨</h4>
                    <div className="flex gap-2 overflow-x-auto">
                      {currentActor.weapons.map(weapon => (
                        <button
                          key={weapon.id}
                          onClick={() => updateChar(currentActor.id, { activeWeapon: weapon })}
                          className={`px-3 py-2 border rounded text-xs whitespace-nowrap transition-colors ${
                            currentActor.activeWeapon.name === weapon.name
                              ? 'border-blue-500 bg-blue-50 text-blue-700'
                              : 'border-gray-200 bg-white hover:bg-gray-50'
                          }`}
                        >
                          <div className="font-bold">{weapon.name}</div>
                          <div className="text-gray-500">{weapon.damage}</div>
                        </button>
                      ))}
                    </div>
                  </div>
                )}

                {currentActor?.activeWeapon?.type === 'ranged' && (
                  <div className="bg-gray-50 p-3 rounded text-xs border flex items-center gap-2">
                    <span className="font-bold">è·ç¦»(ç )</span>
                    <input type="number" value={shootingDistance} onChange={e=>setShootingDistance(parseInt(e.target.value)||10)} className="w-16 border rounded px-1 text-center" />
                    <span className="text-gray-400 flex-1 text-right">å°„ç¨‹:{currentActor?.activeWeapon.range} | å¼¹è¯:{currentActor?.activeWeapon.ammo}</span>
                  </div>
                )}
                <button onClick={nextTurn} className="w-full py-2 text-xs text-gray-400 hover:text-gray-600">è·³è¿‡</button>
              </div>
            )}
            
            {phase === 'select_maneuver' && (
               <div className="space-y-3">
                 <h3 className="text-center text-sm font-bold">æˆ˜æŠ€ç±»å‹</h3>
                 <div className="grid grid-cols-2 gap-2">
                   {[{id:'disarm',n:'ç¼´æ¢°'},{id:'knockdown',n:'å‡»å€’'},{id:'grapple',n:'å‹åˆ¶'},{id:'push',n:'æ¨æ’'}].map(m=>
                     <button key={m.id} onClick={()=>setManeuverType(m.id)} className={`p-3 border rounded text-xs font-bold ${maneuverType===m.id?'bg-gray-900 text-white':'hover:bg-gray-50'}`}>{m.n}</button>
                   )}
                 </div>
                 <div className="flex gap-2">
                   <button onClick={()=>{setPhase('select_action'); setSelectedCustomSkill(null);}} className="flex-1 py-2 text-xs border rounded">è¿”å›</button>
                   <button onClick={()=>handleCommit('maneuver')} className="flex-[2] bg-black text-white py-2 rounded font-bold text-sm">æ‰§è¡Œ</button>
                 </div>
               </div>
            )}
            
            {phase === 'waiting_defense' && (
               <div className="space-y-4">
                 <div className="flex justify-between items-center px-4 py-2 bg-gray-50 rounded">
                   <div className="text-center">
                     <div className="font-bold text-sm">{combatAction?.attacker.name}</div>
                     <div className="text-[10px] bg-black text-white px-2 rounded inline-block">æ”»</div>
                   </div>
                   <div className="font-black text-xl text-gray-300">VS</div>
                   <div className="text-center">
                     <div className="font-bold text-sm">{combatAction?.target.name}</div>
                     <div className="text-[10px] bg-gray-400 text-white px-2 rounded inline-block">é˜²</div>
                   </div>
                 </div>
                 {targetActor?.status.defenseUsedThisRound && <div className="text-xs text-center text-yellow-800 bg-yellow-50 p-2 rounded">âš ï¸ æœ¬è½®å·²é˜²å¾¡è¿‡ (å¥–åŠ±éª°)</div>}
                 <div className="grid grid-cols-2 gap-3">
                   <button onClick={()=>{setCombatAction(p=>({...p,defenseType:'counter',attackerSkill:p.attacker.fight,defenderSkill:targetActor.fight}));setPhase('input_roll');}} className="bg-red-50 border border-red-200 p-4 rounded hover:bg-red-100"><div className="font-bold text-red-900 text-sm">âš”ï¸ åå‡»</div><div className="text-[10px] text-red-600">{targetActor?.fight}%</div></button>
                   <button onClick={()=>{setCombatAction(p=>({...p,defenseType:'dodge',attackerSkill:p.attacker.fight,defenderSkill:targetActor.dodge}));setPhase('input_roll');}} className="bg-blue-50 border border-blue-200 p-4 rounded hover:bg-blue-100"><div className="font-bold text-blue-900 text-sm">ğŸ’¨ é—ªé¿</div><div className="text-[10px] text-blue-600">{targetActor?.dodge}%</div></button>
                 </div>
               </div>
            )}
            
            {(['input_roll','input_defense_roll','input_damage'].includes(phase)) && combatAction && (
              <div className="space-y-4">
                <h3 className="text-sm font-bold text-center border-b pb-2">{phase==='input_damage'?'ä¼¤å®³ç»“ç®—':(phase==='input_roll'?`${currentActor.name} æ£€å®š`:`${targetActor.name} é˜²å¾¡`)}</h3>
                {phase!=='input_damage' && <div className="text-center"><span className="text-xs text-gray-400 font-bold">ç›®æ ‡å€¼</span><div className="text-3xl font-mono font-bold">{phase==='input_roll'?(combatAction.type==='ranged'?currentActor.firearms:combatAction.attackerSkill):combatAction.defenderSkill}</div></div>}
                {phase==='input_damage' && <div className="text-center font-mono text-sm bg-gray-50 p-2 rounded">{combatAction.damageAttacker?.activeWeapon?.name}</div>}
                <div className="flex gap-2">
                  <input type="number" value={inputValue} onChange={e=>setInputValue(e.target.value)} onKeyDown={e=>e.key==='Enter'&&(phase==='input_damage'?handleDmg():phase==='input_defense_roll'?handleDefenseRoll():handleRoll())} className="w-full text-2xl font-mono border-2 rounded px-2 py-2 text-center focus:border-black outline-none" placeholder={phase==='input_damage'?"0":"1-100"} autoFocus />
                  <button onClick={()=>setInputValue(phase==='input_damage'?calculateDamage(combatAction.damageAttacker?.activeWeapon, combatAction.damageAttacker, combatAction.damageSuccessLevel||1, !!combatAction.isCounterAttack).total:Math.floor(Math.random()*100)+1)} className="px-4 bg-gray-100 font-bold rounded">ğŸ²</button>
                </div>
                <button onClick={phase==='input_damage'?handleDmg:phase==='input_defense_roll'?handleDefenseRoll:handleRoll} disabled={!inputValue} className="w-full bg-black text-white py-3 rounded font-bold text-sm disabled:opacity-50">ç¡®è®¤</button>
              </div>
            )}
          </div>
        </div>
      </div>

      <div className={`panel-right ${mobileTab === 'log' ? 'panel-mobile-active' : ''}`}>
        <div className="p-3 border-b border-gray-200 text-[10px] font-bold text-gray-400 uppercase flex-shrink-0 bg-white">æˆ˜æ–—æ—¥å¿—</div>
        <div className="log-scroll-area" ref={logContainerRef}>
          <div className="space-y-3">
            {logs.map(log => (
              <div key={log.id} className="flex flex-col items-start">
                <div className="text-[9px] text-gray-300 mb-1 font-mono pl-1">{log.time}</div>
                <div className={`p-2.5 rounded-lg text-xs leading-relaxed border shadow-sm ${log.type==='damage'?'bg-red-50 border-red-100 text-red-900':log.type==='success'?'bg-green-50 border-green-100 text-green-900':log.type==='roll'?'bg-white border-gray-200 text-gray-700 font-mono':log.type==='system'?'bg-blue-50 border-blue-100 text-blue-900':'bg-white border-gray-100 text-gray-600'}`}>{log.text}</div>
              </div>
            ))}
          </div>
        </div>
      </div>

      <div className="mobile-nav md:hidden lg:hidden fixed bottom-0 left-0 w-full h-14 bg-white border-t flex justify-around items-center z-50 shadow-lg">
        <button onClick={() => setMobileTab('status')} className={`flex flex-col items-center justify-center w-full h-full transition-colors ${mobileTab==='status'?'text-blue-600':'text-gray-400'}`}>
          <span className="text-lg">ğŸ“Š</span>
          <span className="text-[10px] font-bold">çŠ¶æ€</span>
        </button>
        <button onClick={() => setMobileTab('action')} className={`flex flex-col items-center justify-center w-full h-full transition-colors ${mobileTab==='action'?'text-blue-600':'text-gray-400'}`}>
          <span className="text-lg">âš”ï¸</span>
          <span className="text-[10px] font-bold">è¡ŒåŠ¨</span>
        </button>
        <button onClick={() => setMobileTab('log')} className={`flex flex-col items-center justify-center w-full h-full transition-colors ${mobileTab==='log'?'text-blue-600':'text-gray-400'}`}>
          <span className="text-lg">ğŸ“œ</span>
          <span className="text-[10px] font-bold">æ—¥å¿—</span>
        </button>
      </div>
    </div>
  );
}

// ... MedicalDrawer ä¿æŒä¸å˜ ...
function MedicalDrawer({ isOpen, onClose, characters, updateChar, addLog }) {
  const [tId, setTId] = useState(''); 
  const [hId, setHId] = useState('');
  
  const heal = (isMed) => {
    const t = characters.find(c=>c.id===tId), h = characters.find(c=>c.id===hId);
    if (!t || !h) return;
    addLog(`${isMed?'âš•ï¸':'ğŸ©¹'} ${h.name} å¯¹ ${t.name} æ²»ç–—`, "system");
    if (t.status.dying) { 
      updateChar(tId, { hp: isMed?rollDice("1D3").total:1, status: { ...t.status, dying: false } }); 
      addLog(`âœ… ${t.name} è„±ç¦»æ¿’æ­»`, "success"); 
    } else { 
      const rec = isMed?rollDice("1D3").total:1; 
      updateChar(tId, { hp: Math.min(t.maxHp, t.hp + rec) }); 
      addLog(`âœ… æ¢å¤ ${rec} HP`, "success"); 
    }
  };
  
  return (
    <>
      {isOpen && <div className="fixed inset-0 bg-black/20 z-40" onClick={onClose} />}
      <div className={`fixed inset-y-0 right-0 w-72 bg-white shadow-2xl transform transition duration-300 z-50 flex flex-col ${isOpen ? 'translate-x-0' : 'translate-x-full'}`}>
        <div className="p-4 border-b flex justify-between items-center bg-gray-50">
          <h2 className="font-bold">ğŸ¥ åŒ»ç–—ç«™</h2>
          <button onClick={onClose} className="text-2xl">&times;</button>
        </div>
        <div className="p-4 space-y-4 flex-1 overflow-y-auto">
          <div>
            <label className="text-xs font-bold text-gray-400">æ–½æ•‘è€…</label>
            <select className="w-full border rounded p-2 text-sm" value={hId} onChange={e=>setHId(e.target.value)}>
              <option value="">--</option>
              {characters.filter(c=>c.hp>0).map(c=><option key={c.id} value={c.id}>{c.name}</option>)}
            </select>
          </div>
          <div>
            <label className="text-xs font-bold text-gray-400">ä¼¤å‘˜</label>
            <select className="w-full border rounded p-2 text-sm" value={tId} onChange={e=>setTId(e.target.value)}>
              <option value="">--</option>
              {characters.map(c=><option key={c.id} value={c.id}>{c.name} ({c.hp})</option>)}
            </select>
          </div>
          <div className="grid grid-cols-2 gap-2 pt-4">
            <button disabled={!tId||!hId} onClick={()=>heal(false)} className="border p-3 rounded hover:bg-green-50 font-bold text-sm disabled:opacity-50">ğŸ©¹ æ€¥æ•‘ (1HP)</button>
            <button disabled={!tId||!hId} onClick={()=>heal(true)} className="border p-3 rounded hover:bg-blue-50 font-bold text-sm disabled:opacity-50">âš•ï¸ åŒ»å­¦ (1D3)</button>
          </div>
        </div>
      </div>
    </>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>